<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Scrolling Text GIF Generator</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=DM+Mono:wght@400;500&display=swap');
        
        body {
            margin: 0;
            padding: 20px;
            font-family: 'DM Mono', monospace;
            background: #1a1a1a;
            color: #fff;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }
        
        .controls {
            background: #2a2a2a;
            padding: 20px;
            border-radius: 8px;
            width: 100%;
            max-width: 600px;
        }
        
        .control-group {
            margin-bottom: 15px;
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            font-size: 14px;
        }
        
        input, select {
            width: 100%;
            padding: 8px;
            background: #1a1a1a;
            border: 1px solid #444;
            color: #fff;
            border-radius: 4px;
            font-family: 'DM Mono', monospace;
            box-sizing: border-box;
        }
        
        button {
            width: 100%;
            padding: 12px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-family: 'DM Mono', monospace;
            font-size: 16px;
            margin-top: 10px;
        }
        
        button:hover {
            background: #45a049;
        }
        
        button:disabled {
            background: #666;
            cursor: not-allowed;
        }
        
        #preview {
            background: repeating-conic-gradient(#808080 0% 25%, transparent 0% 50%) 50% / 20px 20px;
            border: 2px solid #444;
            border-radius: 8px;
            image-rendering: pixelated;
        }
        
        .status {
            text-align: center;
            padding: 10px;
            background: #2a2a2a;
            border-radius: 4px;
            min-height: 20px;
        }
        
        .progress {
            width: 100%;
            height: 20px;
            background: #1a1a1a;
            border-radius: 4px;
            overflow: hidden;
            margin-top: 10px;
        }
        
        .progress-bar {
            height: 100%;
            background: #4CAF50;
            width: 0%;
            transition: width 0.3s;
        }
        
        .info {
            background: #2a2a2a;
            padding: 15px;
            border-radius: 4px;
            font-size: 13px;
            line-height: 1.6;
        }
        
        .log {
            background: #1a1a1a;
            padding: 15px;
            border-radius: 4px;
            font-size: 12px;
            line-height: 1.4;
            max-height: 300px;
            overflow-y: auto;
            font-family: 'DM Mono', monospace;
            color: #0f0;
            max-width: 600px;
            width: 100%;
        }
        
        .log-entry {
            margin: 2px 0;
        }
        
        .log-error {
            color: #ff6b6b;
        }
        
        .log-success {
            color: #52b788;
        }
        
        .log-info {
            color: #4ecdc4;
        }
    </style>
</head>
<body>
    <div class="controls">
        <h2>Scrolling Text GIF/WebP Generator</h2>
        
        <div class="control-group">
            <label>Text:</label>
            <input type="text" id="text" value="10 ★ peak 5 ★ fav 4 ★ cool 3 ★ bland 2 ★ ugly 1 ★ ass">
        </div>
        
        <div class="control-group">
            <label>Font Size (px):</label>
            <input type="number" id="fontSize" value="64" min="20" max="200">
        </div>
        
        <div class="control-group">
            <label>Scroll Speed (px/frame):</label>
            <input type="number" id="speed" value="3" min="1" max="20">
        </div>
        
        <div class="control-group">
            <label>Canvas Width (px):</label>
            <input type="number" id="width" value="800" min="400" max="2000">
        </div>
        
        <div class="control-group">
            <label>Frame Delay (ms):</label>
            <input type="number" id="delay" value="33" min="16" max="100">
        </div>
        
        <div class="control-group">
            <label>Format:</label>
            <select id="format">
                <option value="gif">GIF</option>
                <option value="webp">WebP (not supported in all browsers)</option>
            </select>
        </div>
        
        <button id="generateBtn">Generate Animation</button>
        
        <div class="status" id="status">Click Generate to create your animation</div>
        <div class="progress" id="progressContainer" style="display: none;">
            <div class="progress-bar" id="progressBar"></div>
        </div>
    </div>
    
    <canvas id="preview"></canvas>
    
    <div class="info">
        <strong>Note:</strong> Each rating (1 ★ ass, 2 ★ ugly, etc.) gets a unique color. The animation loops seamlessly.
    </div>
    
    <div class="log" id="log">
        <div class="log-entry log-info">[LOG] Ready to generate...</div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/gif.js/0.2.0/gif.js"></script>
    <script>
        const canvas = document.getElementById('preview');
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        const generateBtn = document.getElementById('generateBtn');
        const status = document.getElementById('status');
        const progressContainer = document.getElementById('progressContainer');
        const progressBar = document.getElementById('progressBar');
        const logDiv = document.getElementById('log');
        
        function log(message, type = 'info') {
            const entry = document.createElement('div');
            entry.className = `log-entry log-${type}`;
            const timestamp = new Date().toLocaleTimeString();
            entry.textContent = `[${timestamp}] ${message}`;
            logDiv.appendChild(entry);
            logDiv.scrollTop = logDiv.scrollHeight;
            console.log(message);
        }
        
        // Rainbow colors for each rating
        const ratingColors = [
            '#FF6B6B', // 1 - red
            '#FFA500', // 2 - orange
            '#FFD700', // 3 - gold
            '#4ECDC4', // 4 - cyan
            '#45B7D1', // 5 - blue
            '#BB8FCE', // 6 - purple
            '#52B788', // 7 - green
            '#F8B739', // 8 - yellow
            '#FF69B4', // 9 - pink
            '#00FF00'  // 10 - lime
        ];
        
        let fontLoaded = false;
        
        // Load font
        document.fonts.load('64px "DM Mono"').then(() => {
            fontLoaded = true;
            log('DM Mono font loaded successfully', 'success');
            updatePreview();
        }).catch(err => {
            log('Error loading font: ' + err.message, 'error');
        });
        
        function parseRatings(text) {
            const parts = text.split(/\s+/);
            const ratings = [];
            let defaultColorIndex = 0;
            
            for (let i = 0; i < parts.length; i++) {
                if (!parts[i]) continue;

                // Check if this part starts a rating (number followed by ★)
                if (i + 1 < parts.length && parts[i + 1] === '★') {
                    const rating = parts[i];
                    const star = parts[i + 1];
                    const label = parts[i + 2] || '';
                    
                    let colorIndex = parseInt(rating) - 1;
                    if (isNaN(colorIndex)) {
                        colorIndex = defaultColorIndex % ratingColors.length;
                    }
                    
                    ratings.push({
                        text: `${rating} ${star} ${label}`,
                        colorIndex: colorIndex
                    });
                    i += 2; // Skip star and label
                } else {
                    // Regular text
                    ratings.push({
                        text: parts[i],
                        colorIndex: defaultColorIndex % ratingColors.length
                    });
                    defaultColorIndex++;
                }
            }
            
            return ratings;
        }
        
        function drawText(offset, fontSize, canvasWidth, canvasHeight) {
            ctx.clearRect(0, 0, canvasWidth, canvasHeight);
            
            const text = document.getElementById('text').value;
            const ratings = parseRatings(text);
            
            ctx.font = `500 ${fontSize}px 'DM Mono', monospace`;
            ctx.textBaseline = 'middle';
            
            // Measure total width
            let totalWidth = 0;
            const spacing = fontSize * 0.8;
            
            for (let i = 0; i < ratings.length; i++) {
                totalWidth += ctx.measureText(ratings[i].text).width;
                if (i < ratings.length - 1) {
                    totalWidth += spacing;
                }
            }
            
            // Add extra spacing at the end before loop
            totalWidth += spacing;
            
            // Safeguard against infinite loop if text is empty
            if (totalWidth <= spacing || ratings.length === 0) return 0;
            
            // Draw text multiple times for seamless scroll
            const repetitions = Math.ceil(canvasWidth / totalWidth) + 2;
            
            for (let rep = 0; rep < repetitions; rep++) {
                let x = (rep * totalWidth) - offset;
                
                for (let i = 0; i < ratings.length; i++) {
                    const rating = ratings[i];
                    
                    // Handle color index safely (including negative numbers)
                    let colorIndex = rating.colorIndex % ratingColors.length;
                    if (colorIndex < 0) colorIndex += ratingColors.length;
                    
                    ctx.fillStyle = ratingColors[colorIndex];
                    ctx.fillText(rating.text, x, canvasHeight / 2);
                    
                    x += ctx.measureText(rating.text).width + spacing;
                }
            }
            
            return totalWidth;
        }
        
        function updatePreview() {
            if (!fontLoaded) return;
            
            const fontSize = parseInt(document.getElementById('fontSize').value);
            const canvasWidth = parseInt(document.getElementById('width').value);
            const gap = Math.ceil(fontSize * 0.3);
            const canvasHeight = fontSize + gap * 2;
            
            canvas.width = canvasWidth;
            canvas.height = canvasHeight;
            
            drawText(0, fontSize, canvasWidth, canvasHeight);
        }
        
        async function generateGIF() {
            const fontSize = parseInt(document.getElementById('fontSize').value);
            const speed = parseInt(document.getElementById('speed').value);
            const canvasWidth = parseInt(document.getElementById('width').value);
            const delay = parseInt(document.getElementById('delay').value);
            const format = document.getElementById('format').value;
            
            log(`Starting generation with settings:`, 'info');
            log(`  Font size: ${fontSize}px`, 'info');
            log(`  Speed: ${speed}px/frame`, 'info');
            log(`  Width: ${canvasWidth}px`, 'info');
            log(`  Frame delay: ${delay}ms`, 'info');
            log(`  Format: ${format}`, 'info');
            
            const gap = Math.ceil(fontSize * 0.3);
            const canvasHeight = fontSize + gap * 2;
            
            canvas.width = canvasWidth;
            canvas.height = canvasHeight;
            
            log(`Canvas size: ${canvasWidth}x${canvasHeight}`, 'info');
            
            generateBtn.disabled = true;
            progressContainer.style.display = 'block';
            progressBar.style.width = '0%';
            
            try {
                // Measure loop distance
                const loopDistance = drawText(0, fontSize, canvasWidth, canvasHeight);
                const totalFrames = Math.ceil(loopDistance / speed);
                
                log(`Loop distance: ${loopDistance}px`, 'info');
                log(`Total frames needed: ${totalFrames}`, 'info');
                
                status.textContent = `Generating ${totalFrames} frames...`;
                
                log('Initializing GIF encoder...', 'info');
                
                const gif = new GIF({
                    workers: 2,
                    quality: 10,
                    width: canvasWidth,
                    height: canvasHeight,
                    transparent: 0x000000,
                    workerScript: 'gif.worker.js'
                });
                
                log('GIF encoder initialized', 'success');
                log('Starting frame capture...', 'info');
                
                // Generate frames
                for (let frame = 0; frame < totalFrames; frame++) {
                    const offset = (frame * speed) % loopDistance;
                    drawText(offset, fontSize, canvasWidth, canvasHeight);
                    
                    gif.addFrame(ctx, { copy: true, delay: delay, transparent: 0x000000 });
                    
                    const progress = ((frame + 1) / totalFrames) * 50;
                    progressBar.style.width = progress + '%';
                    status.textContent = `Capturing frames: ${frame + 1}/${totalFrames}`;
                    
                    if (frame % 10 === 0 || frame === totalFrames - 1) {
                        log(`Captured frame ${frame + 1}/${totalFrames}`, 'info');
                    }
                    
                    // Allow UI to update
                    await new Promise(resolve => setTimeout(resolve, 0));
                }
                
                log('All frames captured successfully', 'success');
                status.textContent = 'Rendering GIF... This may take a moment.';
                log('Starting GIF encoding...', 'info');
                
                gif.on('progress', (p) => {
                    const progress = 50 + (p * 50);
                    progressBar.style.width = progress + '%';
                    if (Math.floor(p * 10) % 2 === 0) {
                        log(`Encoding progress: ${Math.floor(p * 100)}%`, 'info');
                    }
                });
                
                gif.on('finished', (blob) => {
                    log(`GIF encoding complete! Size: ${(blob.size / 1024).toFixed(2)} KB`, 'success');
                    
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `scrolling_text_transparent.${format}`;
                    a.click();
                    
                    log('Download started', 'success');
                    status.textContent = 'Download complete! Ready to generate again.';
                    generateBtn.disabled = false;
                    progressContainer.style.display = 'none';
                    progressBar.style.width = '0%';
                });
                
                gif.on('abort', () => {
                    log('GIF rendering was aborted', 'error');
                    generateBtn.disabled = false;
                });
                
                gif.render();
                
            } catch (error) {
                log(`ERROR: ${error.message}`, 'error');
                log(`Stack trace: ${error.stack}`, 'error');
                status.textContent = 'Error occurred! Check log.';
                generateBtn.disabled = false;
                progressContainer.style.display = 'none';
            }
        }
        
        generateBtn.addEventListener('click', generateGIF);
        
        // Update preview on input change
        document.getElementById('text').addEventListener('input', updatePreview);
        document.getElementById('fontSize').addEventListener('input', updatePreview);
        document.getElementById('width').addEventListener('input', updatePreview);
        
        // Initial preview
        updatePreview();
    </script>
</body>
</html>